#include "mrac.h"
#include <math.h>

// MRAC Controller Function Implementation
void initMRAC(MRAC *mrac, float sampling_time, float gamma, float settling_time, float gain_correction, float phase_shift)
{
  // general
  mrac->sampling_time = sampling_time;
  mrac->gamma = gamma;
  mrac->r_kminus1 = 0;
  mrac->y_kminus1 = 0;
  mrac->u_kminus1 = 0;
  mrac->e_kminus1 = 0;
  mrac->sin_kminus1 = 0;
  mrac->cos_kminus1 = 0;
  mrac->output_boundary = 999999;

  // reference model
  mrac->settling_time = settling_time;
  calculateMRcoefficients(mrac);
  mrac->yw_kminus1 = 0;

  // zeta matrix
  mrac->zeta_x1_kminus1 = 0;
  mrac->zeta_y_kminus1 = 0;
  mrac->zeta_r_kminus1 = 0;

  // zeta augmented matrix for disturbance rejection
  mrac->zeta_sin_kminus1 = 0;
  mrac->zeta_cos_kminus1 = 0;

  // theta controller parameters solution variables
  mrac->theta_x1_kminus1 = 0;
  mrac->theta_y_kminus1 = 0;
  mrac->theta_r_kminus1 = 0;
  mrac->theta_sin_kminus1 = 0;
  mrac->theta_cos_kminus1 = 0;
  // optimizing a repetitive product
  mrac->ts_times_gamma = sampling_time * gamma;

  // phase and gain reference model correction
  mrac->gain_correction = gain_correction;
  mrac->phase_shift = phase_shift;

  // normalization signal
  mrac->one_by_m2_kminus1 = 0;
}

void setMRACgains(MRAC *mrac, float theta_x1, float theta_y, float theta_r, float theta_sin, float theta_cos)
{
  mrac->theta_x1_kminus1 = 0;
  mrac->theta_y_kminus1 = 0;
  mrac->theta_r_kminus1 = 0;
  mrac->theta_sin_kminus1 = 0;
  mrac->theta_cos_kminus1 = 0;
}

void getMRACgains(MRAC *mrac, float *theta_x1, float *theta_y, float *theta_r, float *theta_sin, float *theta_cos)
{
  *theta_x1 = mrac->theta_x1_kminus1;
  *theta_y = mrac->theta_y_kminus1;
  *theta_r = mrac->theta_r_kminus1;
  *theta_sin = mrac->theta_sin_kminus1;
  *theta_cos = mrac->theta_cos_kminus1;
}

void executeMRAC(MRAC *mrac, float ref_al, float ref_be, float y, float x1, float sin, float cos, float *control_action, float *cr, float *y_rm)
{
  // execute reference model
  // VERIFICAR
  float corrected_reference = phase_shift_gain_correction(ref_al, ref_be, mrac->gain_correction, mrac->phase_shift);
  float yw = mrac->beta1_w * corrected_reference + mrac->beta0_w * mrac->r_kminus1 - mrac->alpha0_w * mrac->yw_kminus1;

  float common_factor = mrac->ts_times_gamma * mrac->e_kminus1 * mrac->one_by_m2_kminus1;
  // update theta related to X1 state
  float theta_x1 = mrac->theta_x1_kminus1 - common_factor * mrac->zeta_x1_kminus1;
  // update theta related to third state (X2 = y)
  float theta_y = mrac->theta_y_kminus1 - common_factor * mrac->y_kminus1;
  // update theta related to reference
  float theta_r = mrac->theta_r_kminus1 - common_factor * mrac->r_kminus1;
  // update sin noise rejection
  float theta_sin = mrac->theta_sin_kminus1 - common_factor * mrac->zeta_sin_kminus1;
  // update cos noise rejection
  float theta_cos = mrac->theta_cos_kminus1 - common_factor * mrac->zeta_cos_kminus1;

  // update control action
  float u = theta_x1 * x1 + theta_y * y + theta_r * corrected_reference + theta_sin * sin + theta_cos * cos;

  // bounded output
  float u_bounded = u;
  float uu = u * u;
  float sqrt_uu = sqrt(uu);
  if ((uu / sqrt_uu) >= mrac->output_boundary)
    u_bounded = (mrac->output_boundary * u) / sqrt_uu;

  // update error
  float e = y - yw;

  // update normalization signal;
  float m2 = 1 + x1 * x1 + y * y + corrected_reference * corrected_reference + sin * sin + cos * cos;

  // store variables for next iteration
  // general
  mrac->r_kminus1 = corrected_reference; 
  mrac->y_kminus1 = y;
  mrac->sin_kminus1 = sin;
  mrac->cos_kminus1 = cos;
  mrac->yw_kminus1 = yw;
  mrac->u_kminus1 = u_bounded;
  mrac->e_kminus1 = e;
  mrac->one_by_m2_kminus1 = 1.0 / m2;
  // thetas
  mrac->theta_x1_kminus1 = theta_x1;
  mrac->theta_y_kminus1 = theta_y;
  mrac->theta_r_kminus1 = theta_r;
  mrac->theta_sin_kminus1 = theta_sin;
  mrac->theta_cos_kminus1 = theta_cos;
  // zetas
  mrac->zeta_x1_kminus1 = x1;
  mrac->zeta_y_kminus1 = y;
  // VERIFICAR
  mrac->zeta_r_kminus1 = corrected_reference;
  mrac->zeta_sin_kminus1 = sin;
  mrac->zeta_cos_kminus1 = cos;

  // output control action
  *control_action = u_bounded;
  *y_rm = yw; 
  *cr = corrected_reference;
}

void calculateMRcoefficients(MRAC *mrac)
{
  float tau = mrac->settling_time * 0.25;
  float beta_times_ts = (1.0 / tau) * mrac->sampling_time;
  mrac->beta1_w = beta_times_ts / (2 + beta_times_ts);
  mrac->beta0_w = mrac->beta1_w;
  mrac->alpha0_w = (beta_times_ts - 2.0) / (2 + beta_times_ts);
}

void setBoundary(MRAC *mrac, float boundary)
{
  mrac->output_boundary = boundary;
}

void setGain(MRAC *mrac, float gain)
{
  mrac->gain_correction = gain;
}

void setPhaseShift(MRAC *mrac, float phase_shift)
{
  mrac->phase_shift = phase_shift;
}

void setGamma(MRAC *mrac, float gamma)
{
  mrac->gamma = gamma;
  mrac->ts_times_gamma = mrac->sampling_time * gamma;
}

void setSettlingTime(MRAC *mrac, float settling_time)
{
  mrac->settling_time = settling_time;
  calculateMRcoefficients(mrac);
}

extern inline float phase_shift_gain_correction(float ral, float rbe, float gain, float phase)
{
  return gain * (cos(phase) * ral + sin(phase) * rbe);
}